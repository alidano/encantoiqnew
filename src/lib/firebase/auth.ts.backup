import {
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut as firebaseSignOut,
  onAuthStateChanged,
  User as FirebaseUser,
  Auth,
  getIdTokenResult,
} from 'firebase/auth';
import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  serverTimestamp,
  collection,
  getDocs,
  query,
  where,
} from 'firebase/firestore';
import { getAuth } from 'firebase/auth';
import { db } from './config';
import type { User, UserRole, UserDocument, DEFAULT_PERMISSIONS } from '@/types/auth';
import { AVAILABLE_PAGES } from '@/types/auth';

// Admin user IDs and emails - these users will always be admin
const ADMIN_USERS = [
  { uid: 'TTBNuPEvjLONI7SBRVKLX73QXrr2', email: 'alidano@gmail.com' },
  { uid: 'JF3YDqRbdBfgf39QkFJi19RbYr53', email: 'luis@lofagroup.com' },
  { uid: 'sBSZeFPayOZHCI9PgcsmlbPXvp72', email: 'emaria@encantotree.com' },
];

// Regular users - limited access
const REGULAR_USERS = [
  { uid: 'zH9tl4oteOXTUn7DnRd7HY97HHQ2', email: 'fquintero@encantotree.com' },
  { uid: 'DDmmVwKqa6RD3Ukh5kexkAGRdy52', email: 'smartinez@encantotree.com' },
  { uid: 'UnqpXwXhabgEnlLK0NjXehDuYnC2', email: 'jvelasco@encantotree.com' }
];

// Get Firebase Auth instance
export const auth: Auth = getAuth();

// Helper function to safely convert dates
const safeToDate = (dateValue: any): Date => {
  if (!dateValue) return new Date();
  
  // If it's already a Date object
  if (dateValue instanceof Date) return dateValue;
  
  // If it's a Firestore Timestamp with toDate method
  if (dateValue && typeof dateValue.toDate === 'function') {
    return dateValue.toDate();
  }
  
  // If it's a string or number, try to parse it
  if (typeof dateValue === 'string' || typeof dateValue === 'number') {
    const parsed = new Date(dateValue);
    return isNaN(parsed.getTime()) ? new Date() : parsed;
  }
  
  // Fallback to current date
  return new Date();
};

// Convert Firebase user to our User type
export const convertFirebaseUser = async (firebaseUser: FirebaseUser): Promise<User | null> => {
  try {
    // Get user's custom claims first (this is our primary source of truth)
    const idTokenResult = await getIdTokenResult(firebaseUser, true);
    const claims = idTokenResult.claims;

    // Check if this is an admin user (by UID or email)
    const isAdminUser = ADMIN_USERS.some(admin => 
      firebaseUser.uid === admin.uid || firebaseUser.email === admin.email
    );

    // Check if this is a regular user
    const isRegularUser = REGULAR_USERS.some(user => 
      firebaseUser.uid === user.uid || firebaseUser.email === user.email
    );

    // Determine role from custom claims or fallback to user type checking
    let role: UserRole = 'user';
    let allowedPages: string[] = ['dashboard', 'patients', 'chat'];

    if (claims.admin === true || claims.role === 'admin' || isAdminUser) {
      role = 'admin';
      allowedPages = ['dashboard', 'patients', 'submissions', 'chat', 'reports', 'settings', 'admin'];
    } else if (claims.role === 'user' || isRegularUser) {
      role = 'user';
      allowedPages = ['dashboard', 'patients', 'submissions', 'chat'];
    }

    // Get or create user document in Firestore for additional data
    const userDocRef = doc(db, 'users', firebaseUser.uid);
    const userDoc = await getDoc(userDocRef);
    
    if (!userDoc.exists()) {
      // Create user document if it doesn't exist
      const newUserData: UserDocument = {
        email: firebaseUser.email || '',
        role: role,
        allowedPages: [...allowedPages],
        isActive: true,
        createdAt: serverTimestamp(),
        lastLogin: serverTimestamp(),
      };
      
      await setDoc(userDocRef, newUserData);
      
      return {
        uid: firebaseUser.uid,
        email: firebaseUser.email,
        displayName: firebaseUser.displayName,
        photoURL: firebaseUser.photoURL,
        role: role,
        allowedPages: [...allowedPages],
        isActive: true,
        createdAt: new Date(),
        lastLogin: new Date(),
      };
    }

    // If user exists, get data from Firestore
    const existingUserData = userDoc.data() as UserDocument;

    // Update last login
    await updateDoc(userDocRef, {
      lastLogin: serverTimestamp(),
    });
    
    return {
      uid: firebaseUser.uid,
      email: firebaseUser.email,
      displayName: firebaseUser.displayName,
      photoURL: firebaseUser.photoURL,
      role: role, // Use role from custom claims
      allowedPages: allowedPages, // Use permissions from custom claims
      isActive: existingUserData.isActive !== false, // Default to true if not set
      createdAt: safeToDate(existingUserData.createdAt),
      lastLogin: new Date(),
    };
  } catch (error) {
    console.error('Error converting Firebase user:', error);
    return null;
  }
};

// Sign in with email and password
export const signIn = async (email: string, password: string): Promise<User> => {
  try {
    const userCredential = await signInWithEmailAndPassword(auth, email, password);
    const user = await convertFirebaseUser(userCredential.user);
    
    if (!user) {
      throw new Error('Failed to load user data');
    }
    
    if (!user.isActive) {
      await firebaseSignOut(auth);
      throw new Error('Account is deactivated. Please contact an administrator.');
    }
    
    return user;
  } catch (error: any) {
    console.error('Sign in error:', error);
    throw new Error(error.message || 'Failed to sign in');
  }
};

// Sign up with email and password (admin only)
export const signUp = async (
  email: string, 
  password: string, 
  role: UserRole = 'user'
): Promise<User> => {
  try {
    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
    
    // Create user document in Firestore
    const allowedPages = role === 'admin' ? [...AVAILABLE_PAGES] : [...DEFAULT_PERMISSIONS.user];
    
    const userData: UserDocument = {
      email: email,
      role: role,
      allowedPages: allowedPages,
      isActive: true,
      createdAt: serverTimestamp(),
      lastLogin: serverTimestamp(),
    };
    
    await setDoc(doc(db, 'users', userCredential.user.uid), userData);
    
    const user = await convertFirebaseUser(userCredential.user);
    
    if (!user) {
      throw new Error('Failed to create user data');
    }
    
    return user;
  } catch (error: any) {
    console.error('Sign up error:', error);
    throw new Error(error.message || 'Failed to create account');
  }
};

// Sign out
export const signOut = async (): Promise<void> => {
  try {
    await firebaseSignOut(auth);
  } catch (error: any) {
    console.error('Sign out error:', error);
    throw new Error(error.message || 'Failed to sign out');
  }
};

// Update user role (admin only)
export const updateUserRole = async (userId: string, role: UserRole): Promise<void> => {
  try {
    const userDocRef = doc(db, 'users', userId);
    const defaultPages = role === 'admin' ? [...AVAILABLE_PAGES] : [...DEFAULT_PERMISSIONS.user];
    
    await updateDoc(userDocRef, {
      role: role,
      allowedPages: defaultPages,
    });
  } catch (error: any) {
    console.error('Update user role error:', error);
    throw new Error(error.message || 'Failed to update user role');
  }
};

// Update user permissions (admin only)
export const updateUserPermissions = async (userId: string, allowedPages: string[]): Promise<void> => {
  try {
    const userDocRef = doc(db, 'users', userId);
    await updateDoc(userDocRef, {
      allowedPages: allowedPages,
    });
  } catch (error: any) {
    console.error('Update user permissions error:', error);
    throw new Error(error.message || 'Failed to update user permissions');
  }
};

// Get all users (admin only)
export const getAllUsers = async (): Promise<User[]> => {
  try {
    const usersRef = collection(db, 'users');
    const snapshot = await getDocs(usersRef);
    
    const users: User[] = [];
    snapshot.forEach((doc) => {
      const userData = doc.data() as UserDocument;
      users.push({
        uid: doc.id,
        email: userData.email,
        displayName: null,
        photoURL: null,
        role: userData.role,
        allowedPages: userData.allowedPages,
        isActive: userData.isActive,
        createdAt: safeToDate(userData.createdAt),
        lastLogin: safeToDate(userData.lastLogin),
      });
    });
    
    return users;
  } catch (error: any) {
    console.error('Get all users error:', error);
    throw new Error(error.message || 'Failed to fetch users');
  }
};

// Toggle user active status (admin only)
export const toggleUserActiveStatus = async (userId: string, isActive: boolean): Promise<void> => {
  try {
    const userDocRef = doc(db, 'users', userId);
    await updateDoc(userDocRef, {
      isActive: isActive,
    });
  } catch (error: any) {
    console.error('Toggle user active status error:', error);
    throw new Error(error.message || 'Failed to update user status');
  }
};

// Check if user has permission
export const hasPermission = (user: User | null, permission: string): boolean => {
  if (!user || !user.isActive) return false;
  if (user.role === 'admin') return true; // Admin has all permissions
  return user.allowedPages.includes(permission);
};

// Check if user is admin
export const isAdmin = (user: User | null): boolean => {
  if (!user || !user.isActive) return false;
  return user.role === 'admin';
};

// Auth state observer
export const onAuthStateChange = (callback: (user: User | null) => void) => {
  return onAuthStateChanged(auth, async (firebaseUser) => {
    if (firebaseUser) {
      const user = await convertFirebaseUser(firebaseUser);
      callback(user);
    } else {
      callback(null);
    }
  });
};

// Initialize admin users if they don't exist in Firestore
export const ensureAdminUsersExist = async (): Promise<void> => {
  try {
    for (const adminUser of ADMIN_USERS) {
      // Check by email first
      const usersRef = collection(db, 'users');
      const emailQuery = query(usersRef, where('email', '==', adminUser.email));
      const emailSnapshot = await getDocs(emailQuery);
      
      if (!emailSnapshot.empty) {
        // Admin user exists by email, ensure they have admin role
        const adminDoc = emailSnapshot.docs[0];
        const userData = adminDoc.data() as UserDocument;
        
        if (userData.role !== 'admin') {
          await updateDoc(adminDoc.ref, {
            role: 'admin',
            allowedPages: [...AVAILABLE_PAGES],
          });
          console.log(`Admin role updated for ${adminUser.email}`);
        }
        continue;
      }
      
      // Check by UID as fallback
      const adminDocRef = doc(db, 'users', adminUser.uid);
      const adminDoc = await getDoc(adminDocRef);
      
      if (!adminDoc.exists()) {
        const adminUserData: UserDocument = {
          email: adminUser.email,
          role: 'admin',
          allowedPages: [...AVAILABLE_PAGES],
          isActive: true,
          createdAt: serverTimestamp(),
          lastLogin: null,
        };
        
        await setDoc(adminDocRef, adminUserData);
        console.log(`Admin user document created for ${adminUser.email}`);
      } else {
        // Ensure existing admin user has correct role and all permissions
        const userData = adminDoc.data() as UserDocument;
        if (userData.role !== 'admin') {
          await updateDoc(adminDocRef, {
            role: 'admin',
            allowedPages: [...AVAILABLE_PAGES],
            email: adminUser.email, // Update email if needed
          });
          console.log(`Admin role updated for ${adminUser.email}`);
        }
      }
    }
  } catch (error) {
    console.error('Error ensuring admin users exist:', error);
  }
};